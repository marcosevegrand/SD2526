\documentclass[11pt, a4paper]{article}

% --- CONFIGURAÇÕES DE FONTE E LÍNGUA (COMPATÍVEL COM PDFLATEX) ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[portuguese]{babel}

% --- PACOTES DE LAYOUT E ESTILO ---
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{titlesec}
\usepackage{setspace}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{graphicx}

% Configuração de cores para blocos de código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.95}

\lstset{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\begin{document}

% --- CAPA ---
    \begin{titlepage}
        \begin{center}
            \vspace*{1cm}
            \Large \textbf{Universidade do Minho}\\
            \large Escola de Engenharia\\
            Licenciatura em Engenharia Informática
            \vfill
            \huge \textbf{Sistemas Distribuídos}\\
            \vspace{0.3cm}
            \LARGE Projeto Prático: Sistema de Gestão de Séries Temporais
            \vfill
            \large \textbf{Grupo 9}\\
            \vspace{0.8cm}
            \begin{tabular}{ll}
                \textbf{Número} & \textbf{Nome} \\
                \midrule
                A106902 & Francisco Martins \\
                A107293 & Hugo Soares \\
                A107372 & Nuno Rebelo \\
                A106807 & Marco Sèvegrand \\
            \end{tabular}
            \vfill
            \large Braga, \today
        \end{center}
    \end{titlepage}

    \newpage
    \pagenumbering{arabic}
    \setstretch{1.3}

    \section{Introdução}
    Este projeto implementa um motor de base de dados para o armazenamento e processamento de séries temporais de vendas. O sistema permite que múltiplos clientes registem eventos em tempo real, consultem agregações estatísticas (quantidade, volume, média, máximo) e subscrevam notificações de padrões específicos. O desenho da solução focou-se na persistência de grandes quantidades de dados, na garantia de integridade em ambientes concorrentes e na redução da latência através de uma hierarquia de cache em memória.

    \section{Arquitetura do Sistema}
    O sistema adota uma estrutura em camadas para isolar as responsabilidades de rede, lógica de negócio e armazenamento. O servidor utiliza um \textit{pool} de threads para processar pedidos de forma não bloqueante. No lado do cliente, a arquitetura foi desenhada para satisfazer o requisito de uma ligação TCP única, utilizando um \texttt{Demultiplexer} que gere múltiplas threads através de um protocolo de etiquetas (\textit{tags}). A comunicação é feita num formato binário, utilizando \texttt{DataInputStream} e \texttt{DataOutputStream} sobre um sistema de \textit{framing} que garante que as mensagens são transmitidas e lidas na íntegra.

    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.9\textwidth]{arquitetura.png}
        \caption{Diagrama da arquitetura do sistema e fluxo de mensagens entre componentes.}
        \label{fig:arquitetura}
    \end{figure}

    \section{Implementação dos Requisitos}

    \subsection{Autenticação e Gestão de Sessão}
    O sistema impõe autenticação para todas as operações de negócio. A lógica reside no \texttt{UserManager}, que utiliza mecanismos de exclusão mútua (\textit{locks}) para proteger o mapa de utilizadores. Para garantir a persistência, os dados das contas são guardados em disco (\texttt{users.bin}), permitindo que as credenciais sobrevivam a reinicializações do serviço.

    \subsection{Registo de Eventos e Transição Temporal}
    Os eventos do dia corrente são acumulados em memória para maximizar o desempenho de escrita. A operação \texttt{NEW\_DAY} encerra o ciclo temporal: os dados são serializados para ficheiros \texttt{.dat} numerados e as threads bloqueadas em notificações são acordadas. Esta transição é coordenada de forma atómica para que nenhum evento seja perdido durante a mudança de estado.

    \subsection{Agregações Estatísticas e Cache Lazy}
    As agregações são processadas de forma \textit{lazy}: o cálculo só ocorre quando solicitado. Implementámos uma cache de resultados (\texttt{aggCache}) que armazena estatísticas por par dia/produto. Em consultas subsequentes, o sistema reutiliza estes valores, evitando leituras redundantes do disco. Esta estratégia permite que o servidor responda instantaneamente a pedidos sobre períodos históricos longos.

    \subsection{Filtragem Eficiente de Dados}
    No requisito de listagem de eventos, implementámos compressão por dicionário. O servidor identifica produtos únicos no conjunto de resultados e envia um mapeamento de índices inteiros. Esta abordagem reduz o tamanho das mensagens transmitidas, uma vez que os nomes dos produtos não são repetidos na rede, otimizando o uso da largura de banda.

    \subsection{Notificações Bloqueantes com Timeout Implícito}
    As notificações utilizam variáveis de condição (\texttt{Condition.await()}). Se o critério de venda for atingido, a thread é sinalizada. Caso o dia termine antes da satisfação do padrão, a transição para um novo dia força o despertar das threads com um retorno nulo ou negativo, cumprindo a semântica de tempo real exigida.

    \subsection{Ligação TCP Única com Multiplexagem}
    A concorrência no cliente é gerida pela classe \texttt{Demultiplexer}. Esta centraliza a leitura do socket numa thread dedicada, distribuindo as respostas pelas threads de aplicação com base na \textit{tag} de correlação. Isto impede o bloqueio de cabeça de linha, permitindo que uma consulta estatística pesada não impeça o envio simultâneo de novos eventos de venda.

    \subsection{Persistência com Gestão de Memória}
    O motor respeita os limites $S$ (séries em RAM) e $D$ (janela histórica). Utilizamos uma cache LRU baseada em \texttt{LinkedHashMap} para gerir as séries carregadas. Se uma série necessária não estiver em memória e o limite $S$ for atingido, os dados são lidos do disco e integrados na cache, forçando a expulsão da entrada menos utilizada. Este mecanismo garante que o motor opera sempre dentro dos limites de memória definidos.

    \section{Validação e Teste}
    A robustez do sistema foi validada através de dois cenários principais de teste. O \texttt{FeatTest} foca-se na correção funcional, testando a integridade das notificações simultâneas e consecutivas, bem como a transição entre ciclos diários e o cálculo básico de agregadores.

    O \texttt{StressTest} avalia o comportamento do sistema sob carga, submetendo o servidor a milhares de inserções simultâneas distribuídas por múltiplos clientes e threads de trabalho. Este teste confirmou a fiabilidade dos mecanismos de sincronização e a integridade dos dados, garantindo que os totais reportados pelo servidor coincidem com os eventos enviados pelos clientes, mesmo em cenários de elevada concorrência.

    \section{Utilização de Ferramentas de IA}
    Conforme o enunciado, o uso de IA foi direcionado para tarefas de suporte e produtividade. Gerámos a estrutura da interface de utilizador e os componentes de teste automático. Todo o código produzido foi revisto e integrado manualmente para garantir a conformidade com o protocolo definido e a estabilidade da aplicação.

    \subsection{Geração da Interface de Utilizador}
    A interface de utilizador foi desenvolvida recorrendo ao seguinte prompt:

    \begin{quote}
        \textit{Utilizando a API definida no ficheiro ClientLib.java anexo, cria uma interface de linha de comando em Java. A CLI deve permitir ao utilizador registar-se, fazer login e executar todos os comandos de negócio, como registar vendas, consultar agregações, filtrar eventos e aguardar notificações. Garante que existe um indicador visual do estado da sessão e que são apresentadas mensagens de ajuda sobre a sintaxe de cada comando.}
    \end{quote}

    Anexámos o ficheiro \texttt{ClientLib.java} ao prompt para assegurar que a interface invocava corretamente os métodos de negócio e respeitava a lógica de comunicação implementada.

    \subsection{Geração das Classes de Teste}

    \subsubsection{Testes Funcionais (FeatTest.java)}
    Para a validação funcional, o prompt utilizado foi:

    \begin{quote}
        \textit{Cria um programa de teste em Java para validar o funcionamento das notificações. Deves lançar threads que fiquem a aguardar por vendas simultâneas e consecutivas, enquanto outras threads inserem eventos de venda. No final, verifica se o sistema liberta corretamente as threads quando o dia é encerrado e se as notificações refletem os eventos registados.}
    \end{quote}

    \subsubsection{Teste de Carga (StressTest.java)}
    Para o teste de carga, utilizou-se o seguinte prompt:

    \begin{quote}
        \textit{Gera um programa que submeta o servidor a um elevado número de pedidos concorrentes. Cria vários clientes, cada um com múltiplas threads, para registar milhares de vendas em simultâneo. No final, o programa deve comparar os totais enviados pelos clientes com os resultados devolvidos pelos agregadores do servidor para garantir que não houve perda de dados durante o processo.}
    \end{quote}

    \subsection{Acesso Rápido a Documentação de API}
    Utilizámos a IA para agilizar a consulta das APIs das bibliotecas padrão do Java. Foi através desta exploração que identificámos o método \texttt{removeEldestEntry()} da classe \texttt{LinkedHashMap}. Esta descoberta permitiu implementar a política de substituição LRU de forma nativa e eficiente, simplificando significativamente a lógica da camada de armazenamento.

    \section{Conclusão}
    O sistema desenvolvido responde aos requisitos técnicos e de desempenho. A arquitetura modular e as otimizações implementadas, como a multiplexagem e a gestão inteligente de memória, garantem um serviço resiliente e capaz de gerir fluxos intensos de dados e consultas complexas com eficácia.

\end{document}
