\documentclass[11pt, a4paper]{article}

% --- CONFIGURAÇÕES DE FONTE E LÍNGUA (COMPATÍVEL COM PDFLATEX) ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[portuguese]{babel}

% --- PACOTES DE LAYOUT E ESTILO ---
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{titlesec}
\usepackage{setspace}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{graphicx}

% Configuração de cores para blocos de código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.95}

\lstset{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\begin{document}

% --- CAPA ---
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        \Large \textbf{Universidade do Minho}\\
        \large Escola de Engenharia\\
        Licenciatura em Engenharia Informática
        \vfill
        \huge \textbf{Sistemas Distribuídos}\\
        \vspace{0.3cm}
        \LARGE Projeto Prático: Sistema de Gestão de Séries Temporais
        \vfill
        \large \textbf{Grupo 9}\\
        \vspace{0.8cm}
        \begin{tabular}{ll}
            \textbf{Número} & \textbf{Nome} \\
            \midrule
            A106902 & Francisco Martins \\
            A107293 & Hugo Soares \\
            A107372 & Nuno Rebelo \\
            A106807 & Marco Sèvegrand \\
        \end{tabular}
        \vfill
        \large Braga, \today
    \end{center}
\end{titlepage}

\newpage
\pagenumbering{arabic}
\setstretch{1.3}

\section{Introdução}
Este projeto implementa um motor de base de dados especializado no armazenamento e processamento eficiente de séries
temporais de vendas. O sistema permite que múltiplos clientes registem eventos de vendas em tempo real, recuperem
agregações estatísticas (quantidade, volume, média, máximo) e recebam notificações de padrões específicos. O foco
principal incidiu na conciliação de três desafios: suportar volumes massivos de dados através de persistência em disco,
manter excelente performance através de cache em memória, e garantir a integridade dos dados num ambiente
multi-utilizador altamente concorrente.

\section{Arquitetura do Sistema}
O sistema foi desenhado em camadas: um servidor multi-threaded que recebe pedidos de clientes, delegando o processamento
a um conjunto de threads de trabalho, enquanto a receção de conexões nunca é interrompida. A persistência segue um
modelo de separação entre dados voláteis (dia corrente em RAM) e histórico (ficheiros em disco). No cliente, uma biblioteca
abstrai completamente a complexidade da rede, oferecendo uma interface síncrona enquanto gere assincronia de respostas
em background através de um demultiplexer baseado em tags.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{arquitetura.png}
  \caption{Diagrama da arquitetura do sistema e fluxo de mensagens entre componentes.}
  \label{fig:arquitetura}
\end{figure}

\section{Implementação dos Requisitos}

\subsection{Autenticação e Gestão de Sessão}
O sistema exige autenticação para qualquer operação excepto registo e login. A autenticação é centralizada no
\texttt{UserManager}, que utiliza um mapa protegido por mutex para manter o registo de utilizadores. Os dados de
utilizadores são persistidos em ficheiro binário após cada novo registo, assegurando que as contas sobrevivem
reinicializações do servidor.

\subsection{Registo de Eventos e Transição Temporal}
Os eventos do dia corrente residem em buffer volátil, otimizado para inserção rápida. A operação \texttt{NEW\_DAY}
simula a progressão do tempo: fecha o dia atual, persiste-o em disco, incrementa o contador de dias e notifica o sistema
de notificações. Esta operação é atómica do ponto de vista dos clientes, garantindo consistência na transição de estado.

\subsection{Agregações Estatísticas e Cache Lazy}
As operações de agregação seguem o modelo lazy: o cálculo é adiado até ao pedido do cliente. O sistema mantém uma cache
de segundo nível que armazena resultados parciais por dia e por produto. Em vez de re-processar ficheiros históricos a
cada consulta, o sistema combina resultados em cache, reduzindo drasticamente o I/O em pedidos repetidos. Isto permite
que o servidor escale a consultas frequentes sem degradação de performance.

\subsection{Filtragem Eficiente de Dados}
Para a listagem de eventos históricos, o protocolo utiliza compressão por dicionário: nomes de produtos repetidos são
substituídos por identificadores inteiros no fluxo de dados transmitido. Esta técnica é especialmente eficaz em séries
temporais com milhares de eventos para o mesmo produto, reduzindo significativamente o consumo de largura de banda sem
perder informação.

\subsection{Notificações Bloqueantes com Timeout Implícito}
As notificações requerem que a thread do cliente fique suspensa até que o padrão seja satisfeito. O sistema utiliza
primitivas de sincronização (\texttt{Condition.await()}) para este fim. Uma decisão crítica de projeto foi o tratamento
da transição de dias: se o dia termina enquanto uma thread aguarda uma notificação, a condição é invalidada e o cliente
recebe uma resposta negativa, cumprindo o comportamento de tempo real exigido.

\subsection{Ligação TCP Única com Multiplexagem}
O requisito de manter uma única ligação TCP por cliente, suportando múltiplos pedidos concorrentes, é satisfeito através
de um protocolo de tags. O cliente aloca uma etiqueta única para cada pedido e aguarda a resposta correspondente. Um
demultiplexer no cliente redireciona respostas da rede para a thread correta. Esta arquitetura elimina problemas de
bloqueio em cabeça de linha, permitindo que pedidos rápidos não fiquem retidos atrás de agregações pesadas.

\subsection{Persistência com Gestão de Memória}
O motor de armazenamento respeita dois parâmetros: $S$ (número máximo de séries em RAM) e $D$ (janela de dias
históricos). Uma cache LRU implementada através de \texttt{LinkedHashMap} garante que apenas as $S$ séries mais
consultadas ocupam memória. Séries excedentes são processadas diretamente do disco sob demanda. O sistema também limpa
automaticamente dados que saem da janela de retenção de $D$ dias, mantendo o uso de disco sob controlo.

\section{Validação e Teste}
A validação funcional confirmou que o sistema gere corretamente notificações simultâneas e consecutivas, bem como a
transição entre dias. O teste de carga submeteu o servidor a 25.000 inserções simultâneas de eventos concorrentes. A
concordância perfeita entre os contadores locais dos testes e os valores devolvidos pelo servidor demonstra a fiabilidade
do sistema sob carga e a ausência de condições de corrida.

\section{Utilização de Ferramentas de IA}
Conforme especificado no enunciado, o uso de IA foi limitado a tarefas periféricas que não constituem o núcleo das
competências de Sistemas Distribuídos avaliadas. A interface de utilizador (\texttt{UI.java}) foi gerada para acelerar
a construção de um cliente interativo, assim como os testes (\texttt{FeatTest.java} e \texttt{StressTest.java}) foram
gerados para validar automaticamente as funcionalidades implementadas. Todas as modificações foram validadas manualmente
e integradas após verificação de conformidade com o protocolo.

\subsection{Geração da Interface de Utilizador}
A classe \texttt{UI.java} foi gerada atravessando um prompt de IA com o seguinte conteúdo:

\begin{quote}
\textit{``Cria uma interface de linha de comando em Java para um cliente que se conecta a um servidor de séries temporais através da classe ClientLib. A interface deve apresentar um menu interativo com os seguintes comandos: registar username password (cria conta), entrar username password (faz login), evento produto qtd preço (regista uma venda), dia (consultando o dia actual), novodia (fecha o dia), filtrar dia p1 p2... (lista eventos de produtos num dia), qtd/vol/media/max produto dias (agregação de 4 tipos), simul produto1 produto2 (aguarda notificação), consec N (aguarda sequencia de N vendas seguidas). Mantém o estado de autenticação do utilizador, mostra indicadores de estado (autenticado ou visitante), e captura erros de sintaxe informando o utilizador da forma correta de usar cada comando.''}
\end{quote}

O código produzido implementou uma estrutura genérica com ciclo de leitura de comandos, métodos auxiliares para cada categoria de operação e um sistema de ajuda integrado. Foram realizadas validações manuais para garantir que cada comando respeitava o protocolo esperado e que as mensagens de erro fossem apropriadas.

\subsection{Geração das Classes de Teste}

\subsubsection{Testes Funcionais (FeatTest.java)}
A classe \texttt{FeatTest.java} foi gerada com o seguinte prompt:

\begin{quote}
\textit{``Cria um teste JUnit que valida a funcionalidade de notificações simultâneas e consecutivas. O teste deve: 1) Lancar duas threads monitoras em paralelo, uma aguardando waitSimultaneous('Banana', 'Maçã') e outra aguardando waitConsecutive(3). 2) Lancar duas threads de ruído que adicionam alguns eventos variados (Banana, Maçã, Uva). 3) Lancar uma terceira thread que envia 3 eventos de Laranja seguidos. 4) Usar CountDownLatch para sincronizacao e permitir que as threads monitoras acordem quando a condição é atingida ou quando o dia termina. 5) Validar que a quantidade total de Laranjas registada corresponde ao esperado.''}
\end{quote}

O código gerado forneceu um esqueleto com threads executoras, sincronização baseada em latches e logs de progresso. O teste foi refinado manualmente para ajustar timings críticos, adicionar pequenas pausas de sincronização entre eventos para evitar race conditions, e melhorar a legibilidade dos logs de saída.

\subsubsection{Teste de Carga (StressTest.java)}
A classe \texttt{StressTest.java} foi gerada com o seguinte prompt:

\begin{quote}
\textit{``Cria um teste de stress que submete o servidor a dezenas de milhares de inserções concorrentes. O teste deve: 1) Criar 5 clientes autenticados, cada um com 5 threads de trabalho. 2) Cada thread insere 1000 eventos de um produto (SuperCPU) com quantidade 1 e preço 10.0, perfazendo 25.000 inserções no total. 3) Manter um contador local esperado (quantidade e volume) que será comparado com os valores devolvidos pelo servidor após a persistência. 4) Usar uma CountDownLatch para sincronizar o início de todas as threads, garantindo que começam aproximadamente ao mesmo tempo. 5) Apos a conclusão de todas as inserções, chamar NEW_DAY para persistir os dados. 6) Validar que a quantidade total e volume no servidor correspondem exatamente aos contadores locais, demonstrando que não houve perda de dados durante a concorrência.''}
\end{quote}

O código produzido incluiu um framework completo de execução com pools de threads, mecanismos de sincronização (CountDownLatch), atomicidade nos contadores (AtomicLong e DoubleAdder) e logs detalhados de progresso. O teste foi validado manualmente e executado com sucesso, confirmando a integridade do sistema sob carga massiva.

\subsection{Acesso Rápido a Documentação de API}
A IA foi também consultada como atalho para localização de API na biblioteca padrão de Java. Num desses momentos, ao investigar formas de implementar uma cache LRU de forma elegante, a IA chamou a atenção para o método \texttt{removeEldestEntry()} da classe \texttt{LinkedHashMap}. Este detalhe, que poderia facilmente passar despercebido numa leitura manual de documentação, revelou-se essencial: permitiu configurar a estrutura de dados de modo a que a remoção do elemento menos recentemente utilizado fosse feita automaticamente sobrescrevendo o método, evitando a necessidade de implementar uma estrutura LRU de raiz e simplificando significativamente o código da camada de persistência em memória.

\section{Conclusão}
O sistema desenvolvido cumpre integralmente os requisitos de eficiência e escalabilidade. A arquitetura modular permite
que cada componente (armazenamento, autenticação, notificações) evolua independentemente. As técnicas empregadas (cache
LRU, agregação lazy, demultiplexing no cliente, compressão de dados) são mecanismos consolidados na engenharia de sistemas
distribuídos que garantem performance adequada mesmo perante volumes de dados massivos e elevada concorrência.

\end{document}