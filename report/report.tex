\documentclass[11pt, a4paper]{article}

% --- CONFIGURAÇÕES DE FONTE E LÍNGUA (PDFlatex) ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[portuguese]{babel}

% --- PACOTES DE LAYOUT E ESTILO ---
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{titlesec}
\usepackage{setspace}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{graphicx}

% Configuração de cores para blocos de código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.95}

\lstset{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\begin{document}

% --- CAPA ---
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}
        \Large \textbf{Universidade do Minho}\\
        \large Escola de Engenharia\\
        Licenciatura em Engenharia Informática
        \vfill
        \huge \textbf{Sistemas Distribuídos}\\
        \vspace{0.3cm}
        \LARGE Trabalho Prático: Base de Dados para Séries Temporais
        \vfill
        \large \textbf{Grupo X}\\
        \vspace{0.8cm}
        \begin{tabular}{ll}
            \textbf{Número} & \textbf{Nome} \\
            \midrule
            Axxxxx & Francisco Martins \\
            Axxxxx & Hugo Soares \\
            Axxxxx & Nuno Rebelo \\
            A106807 & Marco Sèvegrand \\
        \end{tabular}
        \vfill
        \large Braga, \today
    \end{center}
\end{titlepage}

\newpage
\pagenumbering{arabic}
\setstretch{1.2}

\section{Introdução}
O sistema desenvolvido visa gerir séries temporais de vendas de forma eficiente, permitindo o armazenamento de biliões de eventos e o processamento de agregações complexas sob alta concorrência. Este relatório descreve as escolhas arquiteturais e as implementações técnicas que garantem robustez, persistência e suporte a múltiplos clientes concorrentes, respeitando os limites de memória definidos.

\section{Arquitetura do Sistema}
A arquitetura foi desenhada para maximizar o paralelismo e o isolamento de responsabilidades. O sistema divide-se em três grandes camadas:

\subsection{Camada de Rede e Protocolo (Common)}
A classe \texttt{FramedStream} atua como base da comunicação. Ao prefixar cada mensagem com o seu tamanho (\textit{framing}), resolvemos o problema da fragmentação de pacotes TCP.
\begin{itemize}
    \item \textbf{Decisão Autónoma:} Implementação de locks de leitura e escrita independentes no \texttt{FramedStream}, permitindo que o envio de uma resposta não bloqueie a receção de um novo comando no mesmo socket.
\end{itemize}

\subsection{Lógica de Concorrência no Cliente (Demultiplexer)}
Para satisfazer o requisito de uma única ligação por cliente com suporte multi-thread, implementou-se o \texttt{Demultiplexer}. Este utiliza uma thread dedicada para ler do socket e uma \texttt{Map<Integer, Entry>} para encaminhar payloads para as threads que aguardam por uma \textit{tag} específica.

\subsection{Motor de Execução no Servidor (ThreadPool)}
O servidor utiliza um \texttt{ThreadPool} proprietário. O \texttt{ClientHandler} lê o pedido e submete-o imediatamente ao pool, libertando-se para ler o próximo frame do socket.
\begin{itemize}
    \item \textbf{Decisão Autónoma:} O pool foi implementado com uma \texttt{LinkedList} de tarefas e um conjunto fixo de threads trabalhadoras, utilizando \texttt{Condition.notEmpty()} para evitar \textit{busy waiting}.
\end{itemize}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{arquitetura.png}
  \caption{Diagrama da arquitetura do sistema e fluxo de mensagens entre componentes.}
  \label{fig:arquitetura}
\end{figure}

\section{Implementação dos Requisitos}

\subsection{Autenticação e Registo (UserManager)}
A gestão de utilizadores é centralizada no \texttt{UserManager}.
\begin{itemize}
    \item \textbf{Implementação:} Utiliza-se um \texttt{HashMap} para mapear utilizadores a passwords, protegido por um \texttt{ReentrantLock}.
    \item \textbf{Persistência:} Os dados são gravados em \texttt{users.bin} de forma atómica após cada registo.
    \item \textbf{Decisão Autónoma:} O carregamento da base de dados é feito logo no arranque do servidor, garantindo continuidade entre sessões.
\end{itemize}

\subsection{Registo de Eventos e Gestão de Dias (StorageEngine)}
O registo de eventos é feito de forma célere no buffer do dia corrente (\texttt{currentEvents}).
\begin{itemize}
    \item \textbf{Novo Dia:} Ao invocar \texttt{newDay}, o motor fecha o buffer, escreve-o no ficheiro \texttt{day\_N.dat} e incrementa o contador global.
    \item \textbf{Decisão do Enunciado:} Uso exclusivo de \texttt{DataOutputStream} e \texttt{BufferedOutputStream} para garantir que a escrita física é feita em blocos, otimizando o IO de disco.
\end{itemize}

\subsection{Agregações Lazy e Caching}
As operações de agregação (Quantidade, Volume, Média, Máximo) seguem um modelo \textit{lazy}.
\begin{itemize}
    \item \textbf{Implementação:} O \texttt{StorageEngine} mantém uma \texttt{aggCache}. No primeiro pedido de um par (dia, produto), a série histórica é lida e os resultados são guardados.
    \item \textbf{Decisão Autónoma:} Se a agregação abranger múltiplos dias, o motor soma os resultados parciais da cache de cada dia, evitando re-processar dados já agregados.
\end{itemize}

\subsection{Filtragem com Serialização Compacta}
Para listas de eventos potencialmente grandes, implementou-se compressão por dicionário no \texttt{ClientHandler.sendFilteredEvents}.
\begin{itemize}
    \item \textbf{Implementação:} O servidor identifica os nomes únicos, envia uma lista inicial (\texttt{dictList}) e, para cada evento subsequente, envia apenas o índice inteiro correspondente ao nome.
    \item \textbf{Impacto:} Esta decisão reduz o tráfego de rede em cerca de 40-70\% em séries com nomes de produtos longos e repetidos.
\end{itemize}

\subsection{Notificações Bloqueantes (NotificationManager)}
Gerir threads bloqueadas por condições de negócio foi um dos desafios principais.
\begin{itemize}
    \item \textbf{Vendas Simultâneas:} A thread fica suspensa em \texttt{change.await()} enquanto a condição \texttt{(p1 AND p2)} não se verifica.
    \item \textbf{Vendas Consecutivas:} O motor mantém um contador de \textit{streak} e um mapa \texttt{streaksReached}.
    \item \textbf{Decisão Autónoma:} Para evitar falhas quando o dia termina, o \texttt{currentDay} é usado como sentinela: se a thread acorda e o dia mudou, a operação retorna falha/null.
\end{itemize}

\subsection{Suporte Multi-threaded e Demultiplexagem}
O suporte a threads concorrentes no cliente é garantido pelo protocolo de \textit{tags}.
\begin{itemize}
    \item \textbf{Implementação:} A \texttt{ClientLib} gera uma tag única por pedido. O \texttt{Demultiplexer} regista a tag e bloqueia a thread chamadora numa \texttt{Condition} específica. Quando a resposta chega, a thread de receção sinaliza apenas a thread correta.
\end{itemize}

\subsection{Limites de Memória (S e D)}
O limite de $S$ séries em RAM é imposto através de uma cache LRU.
\begin{itemize}
    \item \textbf{Implementação:} Utilizou-se a classe \texttt{LinkedHashMap} com \texttt{removeEldestEntry} para remover automaticamente a série menos usada quando o tamanho excede $S$.
    \item \textbf{Janela de Retenção D:} No \texttt{persistDay}, todos os dados em cache (agregações e séries) que ultrapassem o limiar $D$ são removidos proativamente para libertar memória.
\end{itemize}

\section{Realização de Testes}

\subsection{Teste Funcional (FeatTest)}
Validou a lógica de notificações. O teste provou que threads bloqueadas por \texttt{waitSimul} acordam instantaneamente após o registo do segundo produto, e que o comando \texttt{NEW\_DAY} liberta corretamente threads em espera com o resultado negativo.

\subsection{Teste de Stress e Integridade}
Executou-se uma bateria de 25.000 inserções concorrentes.
\begin{itemize}
    \item \textbf{Cenário:} 5 clientes, cada um com 5 threads, a inserir dados simultaneamente.
    \item \textbf{Observação:} Verificou-se que o uso de \texttt{DoubleAdder} e \texttt{AtomicLong} nos testes de validação coincidiu perfeitamente com os resultados retornados pelo servidor, confirmando que não houve perda de dados por condições de corrida (\textit{race conditions}).
\end{itemize}

\section{Conclusão}
O sistema desenvolvido demonstra a eficácia de uma arquitetura modular em ambientes distribuídos. A implementação do \texttt{Demultiplexer} no cliente e do \texttt{ThreadPool} no servidor permitiu gerir alta concorrência com uma única ligação TCP, cumprindo todos os requisitos de eficiência e serialização compacta. A estratégia de cache LRU e agregações \textit{lazy} garante que o sistema se mantém performante mesmo perante volumes de dados que excedem a capacidade da memória RAM disponível.

\end{document}
